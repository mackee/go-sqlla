package sqlla

import (
	"bytes"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"strings"
)

type Plugin struct {
	Name  string
	Args  map[string]string
	Table *Table
}

func (p *Plugin) outpath() string {
	if outpath, ok := p.Args["outpath"]; ok {
		return outpath
	}
	return fmt.Sprintf("%s.plugin.gen.go", p.Table.TableName)
}

func (p *Plugin) WriteCode(g *Generator) error {
	return nil
}

type Plugins []*Plugin

func (p Plugins) WriteCode(g *Generator, packageName string) error {
	files := make(map[string]*bytes.Buffer, len(p))
	lookupOrCreateFile := func(outpath string) *bytes.Buffer {
		if buf, ok := files[outpath]; ok {
			return buf
		}
		buf := &bytes.Buffer{}
		buf.WriteString("// Code generated by github.com/mackee/go-sqlla/v2/cmd/sqlla. DO NOT EDIT.\n")
		fmt.Fprintf(buf, "package %s\n\n", packageName)
		files[outpath] = buf
		return buf
	}

	for _, plugin := range p {
		w := lookupOrCreateFile(plugin.outpath())
		if err := g.WriteCodeByPlugin(w, plugin.Name, plugin); err != nil {
			return fmt.Errorf("fail to write: plugin=%s: %w", plugin.Name, err)
		}
	}
	for outpath, buf := range files {
		out, err := g.Format(buf.Bytes(), outpath)
		if err != nil {
			slog.Error("fail to format", slog.String("outpath", outpath), slog.Any("error", err))
			out = buf.Bytes()
		}
		f, err := os.Create(outpath)
		if err != nil {
			return fmt.Errorf("fail to create file: outpath=%s: %w", outpath, err)
		}
		defer f.Close()
		if _, err := f.Write(out); err != nil {
			return fmt.Errorf("fail to write file: outpath=%s: %w", outpath, err)
		}
	}
	return nil
}

var errThisCommentIsNotPlugin = errors.New("this comment is not plugin")

func parsePluginsByComments(comments []string) (Plugins, error) {
	plugins := make(Plugins, 0, len(comments))
	for _, comment := range comments {
		plugin, err := parsePluginByComment(comment)
		if errors.Is(err, errThisCommentIsNotPlugin) {
			continue
		}
		if err != nil {
			return nil, fmt.Errorf("fail to parse plugin: args=%s %w", comment, err)
		}
		plugins = append(plugins, plugin)
	}
	return plugins, nil
}

func parsePluginByComment(comment string) (*Plugin, error) {
	pluginStr := strings.TrimPrefix(comment, "//sqlla:plugin ")
	if pluginStr == comment {
		return nil, errThisCommentIsNotPlugin
	}
	nameArgs := strings.Split(pluginStr, " ")
	if len(nameArgs) == 0 {
		return nil, errors.New("plugin name is not specified")
	}
	name := nameArgs[0]
	args := make(map[string]string, len(nameArgs)-1)
	for _, arg := range nameArgs[1:] {
		kv := strings.Split(arg, "=")
		if len(kv) != 2 {
			return nil, errors.New("invalid argument")
		}
		args[kv[0]] = kv[1]
	}

	return &Plugin{
		Name: name,
		Args: args,
	}, nil
}
