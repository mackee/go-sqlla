// Code generated by github.com/mackee/go-sqlla/v2/cmd/sqlla - DO NOT EDIT.
package example

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"database/sql"

	"github.com/mackee/go-sqlla/v2"
)

type itemSQL struct {
	where sqlla.Where
}

func NewItemSQL() itemSQL {
	q := itemSQL{}
	return q
}

var itemAllColumns = []string{
	"`id`", "`name`",
}

type itemSelectSQL struct {
	itemSQL
	Columns     []string
	order       string
	limit       *uint64
	offset      *uint64
	tableAlias  string
	joinClauses []string

	additionalWhereClause     string
	additionalWhereClauseArgs []interface{}

	groupByColumns []string

	isForUpdate bool
}

func (q itemSQL) Select() itemSelectSQL {
	return itemSelectSQL{
		q,
		itemAllColumns,
		"",
		nil,
		nil,
		"",
		nil,
		"",
		nil,
		nil,
		false,
	}
}

func (q itemSelectSQL) Or(qs ...itemSelectSQL) itemSelectSQL {
	ws := make([]sqlla.Where, 0, len(qs))
	for _, q := range qs {
		ws = append(ws, q.where)
	}
	q.where = append(q.where, sqlla.ExprOr(ws))
	return q
}

func (q itemSelectSQL) Limit(l uint64) itemSelectSQL {
	q.limit = &l
	return q
}

func (q itemSelectSQL) Offset(o uint64) itemSelectSQL {
	q.offset = &o
	return q
}

func (q itemSelectSQL) ForUpdate() itemSelectSQL {
	q.isForUpdate = true
	return q
}

func (q itemSelectSQL) TableAlias(alias string) itemSelectSQL {
	q.tableAlias = "`" + alias + "`"
	return q
}

func (q itemSelectSQL) SetColumns(columns ...string) itemSelectSQL {
	q.Columns = make([]string, 0, len(columns))
	for _, column := range columns {
		if strings.ContainsAny(column, "(.`") {
			q.Columns = append(q.Columns, column)
		} else {
			q.Columns = append(q.Columns, "`"+column+"`")
		}
	}
	return q
}

func (q itemSelectSQL) JoinClause(clause string) itemSelectSQL {
	q.joinClauses = append(q.joinClauses, clause)
	return q
}

func (q itemSelectSQL) AdditionalWhereClause(clause string, args ...interface{}) itemSelectSQL {
	q.additionalWhereClause = clause
	q.additionalWhereClauseArgs = args
	return q
}

func (q itemSelectSQL) appendColumnPrefix(column string) string {
	if q.tableAlias == "" || strings.ContainsAny(column, "(.") {
		return column
	}
	return q.tableAlias + "." + column
}

func (q itemSelectSQL) GroupBy(columns ...string) itemSelectSQL {
	q.groupByColumns = make([]string, 0, len(columns))
	for _, column := range columns {
		if strings.ContainsAny(column, "(.`") {
			q.groupByColumns = append(q.groupByColumns, column)
		} else {
			q.groupByColumns = append(q.groupByColumns, "`"+column+"`")
		}
	}
	return q
}

func (q itemSelectSQL) ID(v ItemID, exprs ...sqlla.Operator) itemSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: string(v), Op: op, Column: q.appendColumnPrefix("`id`")}
	q.where = append(q.where, where)
	return q
}

func (q itemSelectSQL) IDIn(vs ...ItemID) itemSelectSQL {
	_vs := make([]string, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, string(v))
	}
	where := sqlla.ExprMultiString{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("`id`")}
	q.where = append(q.where, where)
	return q
}

func (q itemSelectSQL) OrderByID(order sqlla.Order) itemSelectSQL {
	q.order = " ORDER BY " + q.appendColumnPrefix("`id`")
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q itemSelectSQL) Name(v string, exprs ...sqlla.Operator) itemSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: q.appendColumnPrefix("`name`")}
	q.where = append(q.where, where)
	return q
}

func (q itemSelectSQL) NameIn(vs ...string) itemSelectSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("`name`")}
	q.where = append(q.where, where)
	return q
}

func (q itemSelectSQL) OrderByName(order sqlla.Order) itemSelectSQL {
	q.order = " ORDER BY " + q.appendColumnPrefix("`name`")
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q itemSelectSQL) ToSql() (string, []interface{}, error) {
	columns := strings.Join(q.Columns, ", ")
	wheres, vs, err := q.where.ToSql()
	if err != nil {
		return "", nil, err
	}

	tableName := "item"
	if q.tableAlias != "" {
		tableName = tableName + " AS " + q.tableAlias
		pcs := make([]string, 0, len(q.Columns))
		for _, column := range q.Columns {
			pcs = append(pcs, q.appendColumnPrefix(column))
		}
		columns = strings.Join(pcs, ", ")
	}
	query := "SELECT " + columns + " FROM " + tableName
	if len(q.joinClauses) > 0 {
		jc := strings.Join(q.joinClauses, " ")
		query += " " + jc
	}
	if wheres != "" {
		query += " WHERE" + wheres
	}
	if q.additionalWhereClause != "" {
		query += " " + q.additionalWhereClause
		if len(q.additionalWhereClauseArgs) > 0 {
			vs = append(vs, q.additionalWhereClauseArgs...)
		}
	}
	if len(q.groupByColumns) > 0 {
		query += " GROUP BY "
		gbcs := make([]string, 0, len(q.groupByColumns))
		for _, column := range q.groupByColumns {
			gbcs = append(gbcs, q.appendColumnPrefix(column))
		}
		query += strings.Join(gbcs, ", ")
	}
	query += q.order
	if q.limit != nil {
		query += " LIMIT " + strconv.FormatUint(*q.limit, 10)
	}
	if q.offset != nil {
		query += " OFFSET " + strconv.FormatUint(*q.offset, 10)
	}

	if q.isForUpdate {
		query += " FOR UPDATE"
	}

	return query + ";", vs, nil
}

func (q itemSelectSQL) Single(db sqlla.DB) (Item, error) {
	q.Columns = itemAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Item{}, err
	}

	row := db.QueryRow(query, args...)
	return q.Scan(row)
}

func (q itemSelectSQL) SingleContext(ctx context.Context, db sqlla.DB) (Item, error) {
	q.Columns = itemAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Item{}, err
	}

	row := db.QueryRowContext(ctx, query, args...)
	return q.Scan(row)
}

func (q itemSelectSQL) All(db sqlla.DB) ([]Item, error) {
	rs := make([]Item, 0, 10)
	q.Columns = itemAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q itemSelectSQL) AllContext(ctx context.Context, db sqlla.DB) ([]Item, error) {
	rs := make([]Item, 0, 10)
	q.Columns = itemAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q itemSelectSQL) Scan(s sqlla.Scanner) (Item, error) {
	var row Item
	err := s.Scan(
		&row.ID,
		&row.Name,
	)
	return row, err
}

type itemUpdateSQL struct {
	itemSQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q itemSQL) Update() itemUpdateSQL {
	return itemUpdateSQL{
		itemSQL: q,
		setMap:  sqlla.SetMap{},
	}
}

func (q itemUpdateSQL) SetID(v ItemID) itemUpdateSQL {
	q.setMap["`id`"] = v
	return q
}

func (q itemUpdateSQL) WhereID(v ItemID, exprs ...sqlla.Operator) itemUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: string(v), Op: op, Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q itemUpdateSQL) WhereIDIn(vs ...ItemID) itemUpdateSQL {
	_vs := make([]string, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, string(v))
	}
	where := sqlla.ExprMultiString{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q itemUpdateSQL) SetName(v string) itemUpdateSQL {
	q.setMap["`name`"] = v
	return q
}

func (q itemUpdateSQL) WhereName(v string, exprs ...sqlla.Operator) itemUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q itemUpdateSQL) WhereNameIn(vs ...string) itemUpdateSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q itemUpdateSQL) ToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Item{}
	if t, ok := s.(itemDefaultUpdateHooker); ok {
		q, err = t.DefaultUpdateHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}
	setColumns, svs, err := q.setMap.ToUpdateSql()
	if err != nil {
		return "", []interface{}{}, err
	}
	wheres, wvs, err := q.where.ToSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	query := "UPDATE item SET" + setColumns
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", append(svs, wvs...), nil
}
func (q itemUpdateSQL) Exec(db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (q itemUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}

type itemDefaultUpdateHooker interface {
	DefaultUpdateHook(itemUpdateSQL) (itemUpdateSQL, error)
}

type itemInsertSQL struct {
	itemSQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q itemSQL) Insert() itemInsertSQL {
	return itemInsertSQL{
		itemSQL: q,
		setMap:  sqlla.SetMap{},
	}
}

func (q itemInsertSQL) ValueID(v ItemID) itemInsertSQL {
	q.setMap["`id`"] = v
	return q
}

func (q itemInsertSQL) ValueName(v string) itemInsertSQL {
	q.setMap["`name`"] = v
	return q
}

func (q itemInsertSQL) ToSql() (string, []interface{}, error) {
	query, vs, err := q.itemInsertSQLToSql()
	if err != nil {
		return "", []interface{}{}, err
	}
	return query + ";", vs, nil
}

func (q itemInsertSQL) itemInsertSQLToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Item{}
	if t, ok := s.(itemDefaultInsertHooker); ok {
		q, err = t.DefaultInsertHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}
	qs, vs, err := q.setMap.ToInsertSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	query := "INSERT INTO item " + qs

	return query, vs, nil
}

func (q itemInsertSQL) OnDuplicateKeyUpdate() itemInsertOnDuplicateKeyUpdateSQL {
	return itemInsertOnDuplicateKeyUpdateSQL{
		insertSQL:               q,
		onDuplicateKeyUpdateMap: sqlla.SetMap{},
	}
}

func (q itemInsertSQL) Exec(db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {

		return nil, err
	}
	result, err := db.Exec(query, args...)
	return result, err
}

func (q itemInsertSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {

		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err
}

type itemDefaultInsertHooker interface {
	DefaultInsertHook(itemInsertSQL) (itemInsertSQL, error)
}

type itemInsertSQLToSqler interface {
	itemInsertSQLToSql() (string, []interface{}, error)
}

type itemInsertOnDuplicateKeyUpdateSQL struct {
	insertSQL               itemInsertSQLToSqler
	onDuplicateKeyUpdateMap sqlla.SetMap
}

func (q itemInsertOnDuplicateKeyUpdateSQL) ValueOnUpdateID(v ItemID) itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`id`"] = v
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) RawValueOnUpdateID(v sqlla.SetMapRawValue) itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`id`"] = v
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) SameOnUpdateID() itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`id`"] = sqlla.SetMapRawValue("VALUES(`id`)")
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) ValueOnUpdateName(v string) itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`name`"] = v
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) RawValueOnUpdateName(v sqlla.SetMapRawValue) itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`name`"] = v
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) SameOnUpdateName() itemInsertOnDuplicateKeyUpdateSQL {
	q.onDuplicateKeyUpdateMap["`name`"] = sqlla.SetMapRawValue("VALUES(`name`)")
	return q
}

func (q itemInsertOnDuplicateKeyUpdateSQL) ToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Item{}
	if t, ok := s.(itemDefaultInsertOnDuplicateKeyUpdateHooker); ok {
		q, err = t.DefaultInsertOnDuplicateKeyUpdateHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}

	query, vs, err := q.insertSQL.itemInsertSQLToSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	os, ovs, err := q.onDuplicateKeyUpdateMap.ToUpdateSql()
	if err != nil {
		return "", []interface{}{}, err
	}
	query += " ON DUPLICATE KEY UPDATE" + os
	vs = append(vs, ovs...)

	return query + ";", vs, nil
}

func (q itemInsertOnDuplicateKeyUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {

		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err
}

type itemDefaultInsertOnDuplicateKeyUpdateHooker interface {
	DefaultInsertOnDuplicateKeyUpdateHook(itemInsertOnDuplicateKeyUpdateSQL) (itemInsertOnDuplicateKeyUpdateSQL, error)
}

type itemBulkInsertSQL struct {
	insertSQLs []itemInsertSQL
}

func (q itemSQL) BulkInsert() *itemBulkInsertSQL {
	return &itemBulkInsertSQL{
		insertSQLs: []itemInsertSQL{},
	}
}

func (q *itemBulkInsertSQL) Append(iqs ...itemInsertSQL) {
	q.insertSQLs = append(q.insertSQLs, iqs...)
}

func (q *itemBulkInsertSQL) itemInsertSQLToSql() (string, []interface{}, error) {
	if len(q.insertSQLs) == 0 {
		return "", []interface{}{}, fmt.Errorf("sqlla: This itemBulkInsertSQL's InsertSQL was empty")
	}
	iqs := make([]itemInsertSQL, len(q.insertSQLs))
	copy(iqs, q.insertSQLs)

	var s interface{} = Item{}
	if t, ok := s.(itemDefaultInsertHooker); ok {
		for i, iq := range iqs {
			var err error
			iq, err = t.DefaultInsertHook(iq)
			if err != nil {
				return "", []interface{}{}, err
			}
			iqs[i] = iq
		}
	}

	sms := make(sqlla.SetMaps, 0, len(q.insertSQLs))
	for _, iq := range q.insertSQLs {
		sms = append(sms, iq.setMap)
	}

	query, vs, err := sms.ToInsertSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	return "INSERT INTO `item` " + query, vs, nil
}

func (q *itemBulkInsertSQL) ToSql() (string, []interface{}, error) {
	query, vs, err := q.itemInsertSQLToSql()
	if err != nil {
		return "", []interface{}{}, err
	}
	return query + ";", vs, nil
}

func (q *itemBulkInsertSQL) OnDuplicateKeyUpdate() itemInsertOnDuplicateKeyUpdateSQL {
	return itemInsertOnDuplicateKeyUpdateSQL{
		insertSQL:               q,
		onDuplicateKeyUpdateMap: sqlla.SetMap{},
	}
}

func (q *itemBulkInsertSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err
}

type itemDeleteSQL struct {
	itemSQL
}

func (q itemSQL) Delete() itemDeleteSQL {
	return itemDeleteSQL{
		q,
	}
}

func (q itemDeleteSQL) ID(v ItemID, exprs ...sqlla.Operator) itemDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: string(v), Op: op, Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q itemDeleteSQL) IDIn(vs ...ItemID) itemDeleteSQL {
	_vs := make([]string, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, string(v))
	}
	where := sqlla.ExprMultiString{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q itemDeleteSQL) Name(v string, exprs ...sqlla.Operator) itemDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q itemDeleteSQL) NameIn(vs ...string) itemDeleteSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q itemDeleteSQL) ToSql() (string, []interface{}, error) {
	wheres, vs, err := q.where.ToSql()
	if err != nil {
		return "", nil, err
	}

	query := "DELETE FROM item"
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", vs, nil
}

func (q itemDeleteSQL) Exec(db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (q itemDeleteSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}
