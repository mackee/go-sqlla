// Code generated by github.com/mackee/go-sqlla/v2/cmd/sqlla - DO NOT EDIT.
package postgresql

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"database/sql"
	"time"

	"github.com/mackee/go-sqlla/v2"
)

type identitySQL struct {
	where sqlla.Where
}

func NewIdentitySQL() identitySQL {
	q := identitySQL{}
	return q
}

var identityAllColumns = []string{
	"\"id\"", "\"account_id\"", "\"email\"", "\"created_at\"", "\"updated_at\"",
}

type identitySelectSQL struct {
	identitySQL
	Columns     []string
	order       sqlla.OrderWithColumn
	limit       *uint64
	offset      *uint64
	tableAlias  string
	joinClauses []string

	additionalWhereClause func(int) (string, int, []any)
	groupByColumns        []string

	isForUpdate bool
}

func (q identitySQL) Select() identitySelectSQL {
	return identitySelectSQL{
		q,
		identityAllColumns,
		nil,
		nil,
		nil,
		"",
		nil, nil,
		nil,
		false,
	}
}

func (q identitySelectSQL) Or(qs ...identitySelectSQL) identitySelectSQL {
	ws := make([]sqlla.Where, 0, len(qs))
	for _, q := range qs {
		ws = append(ws, q.where)
	}
	q.where = append(q.where, sqlla.ExprOr(ws))
	return q
}

func (q identitySelectSQL) Limit(l uint64) identitySelectSQL {
	q.limit = &l
	return q
}

func (q identitySelectSQL) Offset(o uint64) identitySelectSQL {
	q.offset = &o
	return q
}

func (q identitySelectSQL) ForUpdate() identitySelectSQL {
	q.isForUpdate = true
	return q
}

func (q identitySelectSQL) TableAlias(alias string) identitySelectSQL {
	q.tableAlias = "\"" + alias + "\""
	return q
}

func (q identitySelectSQL) SetColumns(columns ...string) identitySelectSQL {
	q.Columns = make([]string, 0, len(columns))
	for _, column := range columns {
		if strings.ContainsAny(column, "(."+"\"") {
			q.Columns = append(q.Columns, column)
		} else {
			q.Columns = append(q.Columns, "\""+column+"\"")
		}
	}
	return q
}

func (q identitySelectSQL) JoinClause(clause string) identitySelectSQL {
	q.joinClauses = append(q.joinClauses, clause)
	return q
}

func (q identitySelectSQL) AdditionalWhereClause(clause func(int) (string, int, []any)) identitySelectSQL {
	q.additionalWhereClause = clause
	return q
}

func (q identitySelectSQL) appendColumnPrefix(column string) string {
	if q.tableAlias == "" || strings.ContainsAny(column, "(.") {
		return column
	}
	return q.tableAlias + "." + column
}

func (q identitySelectSQL) GroupBy(columns ...string) identitySelectSQL {
	q.groupByColumns = make([]string, 0, len(columns))
	for _, column := range columns {
		if strings.ContainsAny(column, "(."+"\"") {
			q.groupByColumns = append(q.groupByColumns, column)
		} else {
			q.groupByColumns = append(q.groupByColumns, "\""+column+"\"")
		}
	}
	return q
}

func (q identitySelectSQL) ID(v IdentityID, exprs ...sqlla.Operator) identitySelectSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: q.appendColumnPrefix("\"id\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) IDIn(vs ...IdentityID) identitySelectSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("\"id\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) OrderByID(order sqlla.Order) identitySelectSQL {
	q.order = order.WithColumn(q.appendColumnPrefix("\"id\""))
	return q
}

func (q identitySelectSQL) AccountID(v AccountID, exprs ...sqlla.Operator) identitySelectSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: q.appendColumnPrefix("\"account_id\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) AccountIDIn(vs ...AccountID) identitySelectSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("\"account_id\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) OrderByAccountID(order sqlla.Order) identitySelectSQL {
	q.order = order.WithColumn(q.appendColumnPrefix("\"account_id\""))
	return q
}

func (q identitySelectSQL) Email(v string, exprs ...sqlla.Operator) identitySelectSQL {
	where := sqlla.ExprValue[string]{Value: v, Op: sqlla.Operators(exprs), Column: q.appendColumnPrefix("\"email\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) EmailIn(vs ...string) identitySelectSQL {
	where := sqlla.ExprMultiValue[string]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("\"email\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) OrderByEmail(order sqlla.Order) identitySelectSQL {
	q.order = order.WithColumn(q.appendColumnPrefix("\"email\""))
	return q
}

func (q identitySelectSQL) CreatedAt(v time.Time, exprs ...sqlla.Operator) identitySelectSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: q.appendColumnPrefix("\"created_at\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) CreatedAtIn(vs ...time.Time) identitySelectSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("\"created_at\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) OrderByCreatedAt(order sqlla.Order) identitySelectSQL {
	q.order = order.WithColumn(q.appendColumnPrefix("\"created_at\""))
	return q
}

func (q identitySelectSQL) UpdatedAt(v time.Time, exprs ...sqlla.Operator) identitySelectSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: q.appendColumnPrefix("\"updated_at\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) UpdatedAtIn(vs ...time.Time) identitySelectSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: q.appendColumnPrefix("\"updated_at\"")}
	q.where = append(q.where, where)
	return q
}

func (q identitySelectSQL) OrderByUpdatedAt(order sqlla.Order) identitySelectSQL {
	q.order = order.WithColumn(q.appendColumnPrefix("\"updated_at\""))
	return q
}

func (q identitySelectSQL) ToSql() (string, []interface{}, error) {
	columns := strings.Join(q.Columns, ", ")
	wheres, offset, vs, err := q.where.ToSqlPg(0)
	if err != nil {
		return "", nil, err
	}

	tableName := "\"identities\""
	if q.tableAlias != "" {
		tableName = tableName + " AS " + q.tableAlias
		pcs := make([]string, 0, len(q.Columns))
		for _, column := range q.Columns {
			pcs = append(pcs, q.appendColumnPrefix(column))
		}
		columns = strings.Join(pcs, ", ")
	}
	query := "SELECT " + columns + " FROM " + tableName
	if len(q.joinClauses) > 0 {
		jc := strings.Join(q.joinClauses, " ")
		query += " " + jc
	}
	if wheres != "" {
		query += " WHERE" + wheres
	}
	if q.additionalWhereClause != nil {
		_query, _offset, _args := q.additionalWhereClause(offset)
		query += " " + _query
		if len(_args) > 0 {
			vs = append(vs, _args...)
		}
		offset = _offset
	}
	if len(q.groupByColumns) > 0 {
		query += " GROUP BY "
		gbcs := make([]string, 0, len(q.groupByColumns))
		for _, column := range q.groupByColumns {
			gbcs = append(gbcs, q.appendColumnPrefix(column))
		}
		query += strings.Join(gbcs, ", ")
	}
	if q.order != nil {
		_query, _ := q.order.OrderExprPg(offset)
		query += " ORDER BY " + _query
		vs = append(vs, q.order.Values()...)
	}
	if q.limit != nil {
		query += " LIMIT " + strconv.FormatUint(*q.limit, 10)
	}
	if q.offset != nil {
		query += " OFFSET " + strconv.FormatUint(*q.offset, 10)
	}

	if q.isForUpdate {
		query += " FOR UPDATE"
	}

	return query + ";", vs, nil
}

func (s Identity) Select() identitySelectSQL {
	return NewIdentitySQL().Select().ID(s.ID)
}
func (q identitySelectSQL) Single(db sqlla.DB) (Identity, error) {
	q.Columns = identityAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Identity{}, err
	}

	row := db.QueryRow(query, args...)
	return q.Scan(row)
}

func (q identitySelectSQL) SingleContext(ctx context.Context, db sqlla.DB) (Identity, error) {
	q.Columns = identityAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Identity{}, err
	}

	row := db.QueryRowContext(ctx, query, args...)
	return q.Scan(row)
}

func (q identitySelectSQL) All(db sqlla.DB) ([]Identity, error) {
	rs := make([]Identity, 0, 10)
	q.Columns = identityAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q identitySelectSQL) AllContext(ctx context.Context, db sqlla.DB) ([]Identity, error) {
	rs := make([]Identity, 0, 10)
	q.Columns = identityAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q identitySelectSQL) Scan(s sqlla.Scanner) (Identity, error) {
	var row Identity
	err := s.Scan(
		&row.ID,
		&row.AccountID,
		&row.Email,
		&row.CreatedAt,
		&row.UpdatedAt,
	)
	return row, err
}

// IterContext returns iter.Seq2[Identity, error] and closer.
//
// The returned Iter.Seq2 assembles and executes a query in the first iteration.
// Therefore, the first iteration may return an error in assembling or executing the query.
// Subsequent iterations read rows. Again, the read may return an error.
//
// closer is a function that closes the row reader object. Execution of this function is idempotent.
// Be sure to call it when you are done using iter.Seq2.
func (q identitySelectSQL) IterContext(ctx context.Context, db sqlla.DB) (func(func(Identity, error) bool), func() error) {
	var rowClose func() error
	closer := func() error {
		if rowClose != nil {
			err := rowClose()
			rowClose = nil
			return err
		}
		return nil
	}

	q.Columns = identityAllColumns
	query, args, err := q.ToSql()
	return func(yield func(Identity, error) bool) {
		if err != nil {
			var r Identity
			yield(r, err)
			return
		}
		rows, err := db.QueryContext(ctx, query, args...)
		if err != nil {
			var r Identity
			yield(r, err)
			return
		}
		rowClose = rows.Close
		for rows.Next() {
			r, err := q.Scan(rows)
			if !yield(r, err) {
				break
			}
		}
	}, closer
}

type identityUpdateSQL struct {
	identitySQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q identitySQL) Update() identityUpdateSQL {
	return identityUpdateSQL{
		identitySQL: q,
		setMap:      sqlla.SetMap{},
	}
}

func (q identityUpdateSQL) SetID(v IdentityID) identityUpdateSQL {
	q.setMap["\"id\""] = int64(v)
	return q
}

func (q identityUpdateSQL) WhereID(v IdentityID, exprs ...sqlla.Operator) identityUpdateSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: "\"id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) WhereIDIn(vs ...IdentityID) identityUpdateSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) SetAccountID(v AccountID) identityUpdateSQL {
	q.setMap["\"account_id\""] = int64(v)
	return q
}

func (q identityUpdateSQL) WhereAccountID(v AccountID, exprs ...sqlla.Operator) identityUpdateSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: "\"account_id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) WhereAccountIDIn(vs ...AccountID) identityUpdateSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"account_id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) SetEmail(v string) identityUpdateSQL {
	q.setMap["\"email\""] = v
	return q
}

func (q identityUpdateSQL) WhereEmail(v string, exprs ...sqlla.Operator) identityUpdateSQL {
	where := sqlla.ExprValue[string]{Value: v, Op: sqlla.Operators(exprs), Column: "\"email\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) WhereEmailIn(vs ...string) identityUpdateSQL {
	where := sqlla.ExprMultiValue[string]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"email\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) SetCreatedAt(v time.Time) identityUpdateSQL {
	q.setMap["\"created_at\""] = v
	return q
}

func (q identityUpdateSQL) WhereCreatedAt(v time.Time, exprs ...sqlla.Operator) identityUpdateSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: "\"created_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) WhereCreatedAtIn(vs ...time.Time) identityUpdateSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"created_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) SetUpdatedAt(v time.Time) identityUpdateSQL {
	q.setMap["\"updated_at\""] = v
	return q
}

func (q identityUpdateSQL) WhereUpdatedAt(v time.Time, exprs ...sqlla.Operator) identityUpdateSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: "\"updated_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) WhereUpdatedAtIn(vs ...time.Time) identityUpdateSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"updated_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityUpdateSQL) ToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Identity{}
	if t, ok := s.(identityDefaultUpdateHooker); ok {
		q, err = t.DefaultUpdateHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}
	setColumns, offset, svs, err := q.setMap.ToUpdateSqlPg(0)
	if err != nil {
		return "", []interface{}{}, err
	}
	wheres, _, wvs, err := q.where.ToSqlPg(offset)
	if err != nil {
		return "", []interface{}{}, err
	}

	query := "UPDATE " + "\"identities\"" + " SET" + setColumns
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", append(svs, wvs...), nil
}
func (s Identity) Update() identityUpdateSQL {
	return NewIdentitySQL().Update().WhereID(s.ID)
}

func (q identityUpdateSQL) Exec(db sqlla.DB) ([]Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	_, err = db.Exec(query, args...)
	if err != nil {
		return nil, err
	}
	qq := q.identitySQL

	return qq.Select().All(db)
}

func (q identityUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) ([]Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	_, err = db.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	qq := q.identitySQL

	return qq.Select().AllContext(ctx, db)
}

type identityDefaultUpdateHooker interface {
	DefaultUpdateHook(identityUpdateSQL) (identityUpdateSQL, error)
}

type identityInsertSQL struct {
	identitySQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q identitySQL) Insert() identityInsertSQL {
	return identityInsertSQL{
		identitySQL: q,
		setMap:      sqlla.SetMap{},
	}
}

func (q identityInsertSQL) ValueID(v IdentityID) identityInsertSQL {
	q.setMap["\"id\""] = int64(v)
	return q
}

func (q identityInsertSQL) ValueAccountID(v AccountID) identityInsertSQL {
	q.setMap["\"account_id\""] = int64(v)
	return q
}

func (q identityInsertSQL) ValueEmail(v string) identityInsertSQL {
	q.setMap["\"email\""] = v
	return q
}

func (q identityInsertSQL) ValueCreatedAt(v time.Time) identityInsertSQL {
	q.setMap["\"created_at\""] = v
	return q
}

func (q identityInsertSQL) ValueUpdatedAt(v time.Time) identityInsertSQL {
	q.setMap["\"updated_at\""] = v
	return q
}

func (q identityInsertSQL) ToSql() (string, []any, error) {
	query, _, vs, err := q.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", []any{}, err
	}
	columns := strings.Join(identityAllColumns, ", ")
	return query + " RETURNING " + columns + ";", vs, nil
}

func (q identityInsertSQL) rowsNum() int {
	return 1
}

func (q identityInsertSQL) identityInsertSQLToSqlPg(offset int) (string, int, []any, error) {
	var err error
	var s interface{} = Identity{}
	if t, ok := s.(identityDefaultInsertHooker); ok {
		q, err = t.DefaultInsertHook(q)
		if err != nil {
			return "", 0, []any{}, err
		}
	}
	qs, offset, vs, err := q.setMap.ToInsertSqlPg(offset)
	if err != nil {
		return "", 0, []any{}, err
	}

	query := "INSERT INTO " + "\"identities\"" + " " + qs
	return query, offset, vs, nil
}

func (q identityInsertSQL) Exec(db sqlla.DB) (Identity, error) {
	return q.ExecContext(context.Background(), db)
}

func (q identityInsertSQL) ExecContext(ctx context.Context, db sqlla.DB) (Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return Identity{}, err
	}
	row := db.QueryRowContext(ctx, query, args...)
	result, err := NewIdentitySQL().Select().Scan(row)
	if err != nil {
		return Identity{}, err
	}
	return result, nil
}

func (q identityInsertSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err
}

type identityDefaultInsertHooker interface {
	DefaultInsertHook(identityInsertSQL) (identityInsertSQL, error)
}

type identityInsertSQLToSqler interface {
	rowsNum() int
	identityInsertSQLToSqlPg(offset int) (string, int, []any, error)
}

type identityBulkInsertSQL struct {
	insertSQLs []identityInsertSQL
}

func (q identitySQL) BulkInsert() *identityBulkInsertSQL {
	return &identityBulkInsertSQL{
		insertSQLs: []identityInsertSQL{},
	}
}

func (q *identityBulkInsertSQL) Append(iqs ...identityInsertSQL) {
	q.insertSQLs = append(q.insertSQLs, iqs...)
}

func (q *identityBulkInsertSQL) rowsNum() int {
	return len(q.insertSQLs)
}

func (q *identityBulkInsertSQL) identityInsertSQLToSqlPg(offset int) (string, int, []any, error) {
	if len(q.insertSQLs) == 0 {
		return "", 0, []any{}, fmt.Errorf("sqlla: This identityBulkInsertSQL's InsertSQL was empty")
	}
	iqs := make([]identityInsertSQL, len(q.insertSQLs))
	copy(iqs, q.insertSQLs)

	var s interface{} = Identity{}
	if t, ok := s.(identityDefaultInsertHooker); ok {
		for i, iq := range iqs {
			var err error
			iq, err = t.DefaultInsertHook(iq)
			if err != nil {
				return "", 0, []any{}, err
			}
			iqs[i] = iq
		}
	}

	sms := make(sqlla.SetMaps, 0, len(q.insertSQLs))
	for _, iq := range q.insertSQLs {
		sms = append(sms, iq.setMap)
	}

	query, offset, vs, err := sms.ToInsertSqlPg(offset)
	if err != nil {
		return "", 0, []any{}, err
	}
	return "INSERT INTO " + "\"identities\"" + " " + query, offset, vs, nil
}

func (q *identityBulkInsertSQL) ToSql() (string, []any, error) {
	query, _, vs, err := q.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", []any{}, err
	}
	columns := strings.Join(identityAllColumns, ", ")
	return query + " RETURNING " + columns + ";", vs, nil
}
func (q *identityBulkInsertSQL) ExecContext(ctx context.Context, db sqlla.DB) ([]Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	results := make([]Identity, 0, len(q.insertSQLs))
	sel := NewIdentitySQL().Select()
	for rows.Next() {
		result, err := sel.Scan(rows)
		if err != nil {
			return nil, err
		}
		results = append(results, result)
	}
	return results, nil
}

func (q *identityBulkInsertSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err
}

type identityInsertOnConflictDoNothingSQL struct {
	insertSQL identityInsertSQLToSqler
}

func (q identityInsertSQL) OnConflictDoNothing() identityInsertOnConflictDoNothingSQL {
	return identityInsertOnConflictDoNothingSQL{
		insertSQL: q,
	}
}

func (q identityInsertOnConflictDoNothingSQL) ToSql() (string, []any, error) {
	query, _, vs, err := q.insertSQL.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", nil, err
	}
	columns := strings.Join(identityAllColumns, ", ")
	query += " ON CONFLICT DO NOTHING" + " RETURNING " + columns
	return query + ";", vs, nil

}

func (q identityInsertOnConflictDoNothingSQL) ExecContext(ctx context.Context, db sqlla.DB) (Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return Identity{}, err
	}
	row := db.QueryRowContext(ctx, query, args...)
	result, err := NewIdentitySQL().Select().Scan(row)
	if err != nil {
		return Identity{}, err
	}
	return result, nil

}

func (q identityInsertOnConflictDoNothingSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {

	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err

}

type identityInsertOnConflictDoUpdateSQL struct {
	insertSQL             identityInsertSQLToSqler
	onConflictDoUpdateMap sqlla.SetMap
	target                string
}

func (q identityInsertSQL) OnConflictDoUpdate(target string) identityInsertOnConflictDoUpdateSQL {
	return identityInsertOnConflictDoUpdateSQL{
		insertSQL:             q,
		onConflictDoUpdateMap: sqlla.SetMap{},
		target:                target,
	}
}

func (q identityInsertOnConflictDoUpdateSQL) ValueOnUpdateID(v IdentityID) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = int64(v)
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) RawValueOnUpdateID(v sqlla.SetMapRawValue) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) SameOnUpdateID() identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = sqlla.SetMapRawValue(`"excluded".` + "\"id\"")
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) ValueOnUpdateAccountID(v AccountID) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = int64(v)
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) RawValueOnUpdateAccountID(v sqlla.SetMapRawValue) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) SameOnUpdateAccountID() identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = sqlla.SetMapRawValue(`"excluded".` + "\"account_id\"")
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) ValueOnUpdateEmail(v string) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) RawValueOnUpdateEmail(v sqlla.SetMapRawValue) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) SameOnUpdateEmail() identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = sqlla.SetMapRawValue(`"excluded".` + "\"email\"")
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) ValueOnUpdateCreatedAt(v time.Time) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) RawValueOnUpdateCreatedAt(v sqlla.SetMapRawValue) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) SameOnUpdateCreatedAt() identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = sqlla.SetMapRawValue(`"excluded".` + "\"created_at\"")
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) ValueOnUpdateUpdatedAt(v time.Time) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) RawValueOnUpdateUpdatedAt(v sqlla.SetMapRawValue) identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = v
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) SameOnUpdateUpdatedAt() identityInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = sqlla.SetMapRawValue(`"excluded".` + "\"updated_at\"")
	return q
}

func (q identityInsertOnConflictDoUpdateSQL) ToSql() (string, []any, error) {
	var err error
	var s any = Identity{}
	if t, ok := s.(identityDefaultInsertOnConflictDoUpdateHooker); ok {
		q, err = t.DefaultInsertOnConflictDoUpdateHook(q)
		if err != nil {
			return "", nil, err
		}
	}

	query, offset, vs, err := q.insertSQL.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", nil, err
	}

	os, _, ovs, err := q.onConflictDoUpdateMap.ToUpdateSqlPg(offset)
	if err != nil {
		return "", nil, err
	}
	query += " ON CONFLICT (" + q.target + ") DO UPDATE SET" + os
	vs = append(vs, ovs...)
	columns := strings.Join(identityAllColumns, ", ")
	query += " RETURNING " + columns

	return query + ";", vs, nil
}

func (q identityInsertOnConflictDoUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) (Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return Identity{}, err
	}
	row := db.QueryRowContext(ctx, query, args...)
	result, err := NewIdentitySQL().Select().Scan(row)
	if err != nil {
		return Identity{}, err
	}
	return result, nil

}

func (q identityInsertOnConflictDoUpdateSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {

	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err

}

type identityDefaultInsertOnConflictDoUpdateHooker interface {
	DefaultInsertOnConflictDoUpdateHook(identityInsertOnConflictDoUpdateSQL) (identityInsertOnConflictDoUpdateSQL, error)
}

type identityBulkInsertOnConflictDoNothingSQL struct {
	insertSQL identityInsertSQLToSqler
}

func (q *identityBulkInsertSQL) OnConflictDoNothing() identityBulkInsertOnConflictDoNothingSQL {
	return identityBulkInsertOnConflictDoNothingSQL{
		insertSQL: q,
	}
}

func (q identityBulkInsertOnConflictDoNothingSQL) ToSql() (string, []any, error) {
	query, _, vs, err := q.insertSQL.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", nil, err
	}
	columns := strings.Join(identityAllColumns, ", ")
	query += " ON CONFLICT DO NOTHING" + " RETURNING " + columns
	return query + ";", vs, nil

}

func (q identityBulkInsertOnConflictDoNothingSQL) ExecContext(ctx context.Context, db sqlla.DB) ([]Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	results := make([]Identity, 0, q.insertSQL.rowsNum())
	sel := NewIdentitySQL().Select()
	for rows.Next() {
		result, err := sel.Scan(rows)
		if err != nil {
			return nil, err
		}
		results = append(results, result)
	}

	return results, nil

}

func (q identityBulkInsertOnConflictDoNothingSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {

	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err

}

type identityBulkInsertOnConflictDoUpdateSQL struct {
	insertSQL             identityInsertSQLToSqler
	onConflictDoUpdateMap sqlla.SetMap
	target                string
}

func (q *identityBulkInsertSQL) OnConflictDoUpdate(target string) identityBulkInsertOnConflictDoUpdateSQL {
	return identityBulkInsertOnConflictDoUpdateSQL{
		insertSQL:             q,
		onConflictDoUpdateMap: sqlla.SetMap{},
		target:                target,
	}
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ValueOnUpdateID(v IdentityID) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = int64(v)
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) RawValueOnUpdateID(v sqlla.SetMapRawValue) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) SameOnUpdateID() identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"id\""] = sqlla.SetMapRawValue(`"excluded".` + "\"id\"")
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ValueOnUpdateAccountID(v AccountID) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = int64(v)
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) RawValueOnUpdateAccountID(v sqlla.SetMapRawValue) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) SameOnUpdateAccountID() identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"account_id\""] = sqlla.SetMapRawValue(`"excluded".` + "\"account_id\"")
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ValueOnUpdateEmail(v string) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) RawValueOnUpdateEmail(v sqlla.SetMapRawValue) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) SameOnUpdateEmail() identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"email\""] = sqlla.SetMapRawValue(`"excluded".` + "\"email\"")
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ValueOnUpdateCreatedAt(v time.Time) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) RawValueOnUpdateCreatedAt(v sqlla.SetMapRawValue) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) SameOnUpdateCreatedAt() identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"created_at\""] = sqlla.SetMapRawValue(`"excluded".` + "\"created_at\"")
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ValueOnUpdateUpdatedAt(v time.Time) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) RawValueOnUpdateUpdatedAt(v sqlla.SetMapRawValue) identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = v
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) SameOnUpdateUpdatedAt() identityBulkInsertOnConflictDoUpdateSQL {
	q.onConflictDoUpdateMap["\"updated_at\""] = sqlla.SetMapRawValue(`"excluded".` + "\"updated_at\"")
	return q
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ToSql() (string, []any, error) {
	var s any = Identity{}
	if t, ok := s.(identityDefaultInsertOnConflictDoUpdateHooker); ok {
		sq := identityInsertOnConflictDoUpdateSQL{
			insertSQL:             q.insertSQL,
			onConflictDoUpdateMap: q.onConflictDoUpdateMap,
			target:                q.target,
		}
		sq, err := t.DefaultInsertOnConflictDoUpdateHook(sq)
		if err != nil {
			return "", nil, err
		}
		q.insertSQL = sq.insertSQL
		q.onConflictDoUpdateMap = sq.onConflictDoUpdateMap
		q.target = sq.target
	}

	query, offset, vs, err := q.insertSQL.identityInsertSQLToSqlPg(0)
	if err != nil {
		return "", nil, err
	}

	os, _, ovs, err := q.onConflictDoUpdateMap.ToUpdateSqlPg(offset)
	if err != nil {
		return "", nil, err
	}
	query += " ON CONFLICT (" + q.target + ") DO UPDATE SET" + os
	vs = append(vs, ovs...)
	columns := strings.Join(identityAllColumns, ", ")
	query += " RETURNING " + columns

	return query + ";", vs, nil
}

func (q identityBulkInsertOnConflictDoUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) ([]Identity, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	results := make([]Identity, 0, q.insertSQL.rowsNum())
	sel := NewIdentitySQL().Select()
	for rows.Next() {
		result, err := sel.Scan(rows)
		if err != nil {
			return nil, err
		}
		results = append(results, result)
	}

	return results, nil

}

func (q identityBulkInsertOnConflictDoUpdateSQL) ExecContextWithoutSelect(ctx context.Context, db sqlla.DB) (sql.Result, error) {

	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	return result, err

}

type identityDeleteSQL struct {
	identitySQL
}

func (q identitySQL) Delete() identityDeleteSQL {
	return identityDeleteSQL{
		q,
	}
}

func (q identityDeleteSQL) ID(v IdentityID, exprs ...sqlla.Operator) identityDeleteSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: "\"id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) IDIn(vs ...IdentityID) identityDeleteSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) AccountID(v AccountID, exprs ...sqlla.Operator) identityDeleteSQL {
	where := sqlla.ExprValue[int64]{Value: int64(v), Op: sqlla.Operators(exprs), Column: "\"account_id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) AccountIDIn(vs ...AccountID) identityDeleteSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiValue[int64]{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"account_id\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) Email(v string, exprs ...sqlla.Operator) identityDeleteSQL {
	where := sqlla.ExprValue[string]{Value: v, Op: sqlla.Operators(exprs), Column: "\"email\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) EmailIn(vs ...string) identityDeleteSQL {
	where := sqlla.ExprMultiValue[string]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"email\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) CreatedAt(v time.Time, exprs ...sqlla.Operator) identityDeleteSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: "\"created_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) CreatedAtIn(vs ...time.Time) identityDeleteSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"created_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) UpdatedAt(v time.Time, exprs ...sqlla.Operator) identityDeleteSQL {
	where := sqlla.ExprValue[time.Time]{Value: v, Op: sqlla.Operators(exprs), Column: "\"updated_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) UpdatedAtIn(vs ...time.Time) identityDeleteSQL {
	where := sqlla.ExprMultiValue[time.Time]{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "\"updated_at\""}
	q.where = append(q.where, where)
	return q
}

func (q identityDeleteSQL) ToSql() (string, []interface{}, error) {
	wheres, _, vs, err := q.where.ToSqlPg(0)
	if err != nil {
		return "", nil, err
	}

	query := "DELETE FROM " + "\"identities\""
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", vs, nil
}

func (q identityDeleteSQL) Exec(db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (q identityDeleteSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}
func (s Identity) Delete(db sqlla.DB) (sql.Result, error) {
	query, args, err := NewIdentitySQL().Delete().ID(s.ID).ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (s Identity) DeleteContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := NewIdentitySQL().Delete().ID(s.ID).ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}
